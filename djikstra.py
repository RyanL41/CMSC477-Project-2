
# -*- coding: utf-8 -*-
"""djikstra's

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q1DysNelGjkZ1z6iYWNe8ubBZ6YO0u2t
"""

import pandas as pd
import numpy as np
import heapq
from scipy.interpolate import CubicSpline

def get_grid_data(csv_path):

  df = pd.read_csv(csv_path, header=None)

  return np.array(df)

def get_padded_grid(grid, radius):
  padded_grid = np.copy(grid)
  obstacles = np.where(grid == 1)
  for (i, j) in zip(obstacles[0], obstacles[1]):

    # calculate all cells in the radius
    for x in range(max(0, i-radius), min(len(grid), i+radius+1)):
      for y in range(max(0, j-radius), min(len(grid[i]), j+radius+1)):
        padded_grid[x][y] = 1

  return padded_grid

def get_neighbors(position, grid):
  neighbors = []
  i, j = position
  if i > 0 and grid[i-1][j] != 1:
    neighbors.append((i-1, j))
  if i < len(grid)-1 and grid[i+1][j] != 1:
    neighbors.append((i+1, j))
  if j > 0 and grid[i][j-1] != 1:
    neighbors.append((i, j-1))
  if j < len(grid[i])-1 and grid[i][j+1] != 1:
    neighbors.append((i, j+1))
  return neighbors

def get_diagonal_neighbors(position, grid):
  neighbors = []
  i, j = position
  if i > 0 and j > 0 and grid[i-1][j-1] != 1:
    neighbors.append((i-1, j-1))
  if i < len(grid)-1 and j < len(grid[i])-1 and grid[i+1][j+1] != 1:
    neighbors.append((i+1, j+1))
  if i > 0 and j < len(grid[i])-1 and grid[i-1][j+1] != 1:
    neighbors.append((i-1, j+1))
  if i < len(grid)-1 and j > 0 and grid[i+1][j-1] != 1:
    neighbors.append((i+1, j-1))
  return neighbors


def djikstra(grid):
  heap_queue = []
  distances = {}
  previous_elements = {}
  starting_position = np.where(grid == 2)
  starting_position = (starting_position[0][0], starting_position[1][0])
  ending_position = np.where(grid == 3)
  ending_position = (ending_position[0][0], ending_position[1][0])

  for i in range(len(grid)):
    for j in range(len(grid[i])):
      if grid[i][j] == 0 or grid[i][j] == 3:
        heap_queue.append((np.inf, (i, j)))
        distances[(i, j)] = np.inf
        previous_elements[(i, j)] = None
      elif grid[i][j] == 2:
        heap_queue.append((0, (i, j)))
        distances[(i, j)] = 0
        previous_elements[(i, j)] = starting_position

  while heap_queue:
    current_distance, current_position = heap_queue.pop(0)
    if current_position == ending_position:
      path = []
      while current_position != starting_position:
        path.append(current_position)
        current_position = previous_elements[current_position]
      path.append(starting_position)
      path.reverse()
      return path


    neighbors = get_neighbors(current_position, grid)
    diagonal_neighbors = get_diagonal_neighbors(current_position, grid)

    for neighbor in neighbors:
      distance = current_distance + 1
      if distance < distances[neighbor]:
        distances[neighbor] = distance
        previous_elements[neighbor] = current_position

        # delete element from heap_queue
        for i in range(len(heap_queue)):
          if heap_queue[i][1] == neighbor:
            del heap_queue[i]
            break

        heap_queue.append((distance, neighbor))
        heap_queue.sort()

    for neighbor in diagonal_neighbors:
      distance = current_distance + np.sqrt(2)
      if distance < distances[neighbor]:
        distances[neighbor] = distance
        previous_elements[neighbor] = current_position

        # delete element from heap_queue
        for i in range(len(heap_queue)):
          if heap_queue[i][1] == neighbor:
            del heap_queue[i]
            break

        heap_queue.append((distance, neighbor))
        heap_queue.sort()

def interpolate_path(points, num_points=1000, bc_type='natural'):

    points = np.array(points)
    x = points[:, 0]
    y = points[:, 1]
    
    # Parameterize by cumulative arc-length to handle non-monotonic x-values.
    distances = np.sqrt(np.diff(x)**2 + np.diff(y)**2)
    t = np.concatenate(([0], np.cumsum(distances)))
    
    # Fit cubic splines for x(t) and y(t)
    cs_x = CubicSpline(t, x, bc_type=bc_type)
    cs_y = CubicSpline(t, y, bc_type=bc_type)
    
    # Create a fine parameter grid for a smooth path
    t_fine = np.linspace(t[0], t[-1], num_points)
    x_fine = cs_x(t_fine)
    y_fine = cs_y(t_fine)
    
    return np.stack([x_fine, y_fine], axis=-1)

def get_path(csv_path, upscaling_factor=4):
  starting_grid = get_grid_data(csv_path)

  upscale_factor = upscaling_factor*2 - 1  # ensure odd number

  upscaled_grid = np.zeros(
    (len(starting_grid) * upscale_factor, len(starting_grid[0]) * upscale_factor)
  )

  for x, row in enumerate(starting_grid):
    for y, cell in enumerate(row):
      if cell in [2, 3]:
        upscaled_grid[x*7+3, y*7+3] = cell
      else:
        upscaled_grid[x*7:x*7+7, y*7:y*7+7] = cell

  padded_grid = get_padded_grid(upscaled_grid, radius=max(upscale_factor - 1, 1))

  path = djikstra(padded_grid)

  path = np.array(path)
  path = (path - (upscaling_factor - 1)) / upscale_factor

  interpolated_path = interpolate_path(path)

  return interpolated_path
